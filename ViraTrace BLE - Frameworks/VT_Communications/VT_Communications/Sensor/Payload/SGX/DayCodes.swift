///**
/**



Created by: Wayne Thornton on 11/10/20
Portions Copyright © 2020 to Present ViraTrace LLC. All Rights Reserved.

This file contains Original Code and/or Modifications of Original code as defined in and that are subject to the ViraTrace Public Source License Version 1.0 (the ‘License’). You may not use this file except in compliance with the License. Please obtain of copy of the Licenses at https://github.com/ViraTrace/License and read it before using this file.

The Original Code and all software distributed under the License are distributed on an ‘AS IS’ basis, WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, AND VIRATRACE HEREBY DISCLAIMS ALL SUCH WARRANTIES, INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT. Please see the License for the specific language governing rights and limitations under the License.

*/

import Foundation

/**
 Day codes are derived from a shared secret that has been agreed with the central server on registration.
 Given a shared secret, a sequence of forward secure day codes is created by recursively hashing (SHA)
 the hash of the shared secret, and using the hashes in reverse order; a day code is generated by taking
 the first eight bytes of a hash as a long value code. It is cryptographically challenging to predict the next
 code given the previous codes. Each day is allocated a day code up to a finite number of days for simplicity.
 */
protocol DayCodes {
    /// Get beacon code seed for a particular day. This is used for deriving the beacon codes for the day.
    func seed(_ timestamp: Timestamp) -> (BeaconCodeSeed, Day)?
}

/// Shared secret between device and server for deriving day codes and beacon codes.
public typealias SharedSecret = Data

/// Day codes are published by the server to enable on-device matching in a de-centralised solution.
typealias DayCode = Int64

/// Day is the number of whole days since epoch (2020-01-01 00:00:00)
typealias Day = UInt

/// Beacon code seed is derived from the day code. This is used to derive the beacon codes for the day.
public typealias BeaconCodeSeed = Int64

/// Timestamp has been abstracted to enable change from Date if required in the future.
typealias Timestamp = Date

class ConcreteDayCodes : DayCodes {
    private let logger = ConcreteSensorLogger(subsystem: "Sensor", category: "Payload.ConcreteDayCodes")
    private let epoch = ConcreteDayCodes.timeIntervalSince1970("2020-01-01T00:00:00+0000")!
    private var values:[DayCode]
    
    init(_ sharedSecret: SharedSecret) {
        let days = 365 * 5
        values = ConcreteDayCodes.dayCodes(sharedSecret, days: days)
    }
    
    static func timeIntervalSince1970(_ from: String) -> UInt64? {
        let formatter = DateFormatter()
        formatter.calendar = Calendar(identifier: .iso8601)
        formatter.locale = Locale(identifier: "en_US_POSIX")
        formatter.timeZone = TimeZone(secondsFromGMT: 0)
        formatter.dateFormat = "yyyy-MM-dd'T'HH:mm:ssXXXX"
        guard let date = formatter.date(from: from) else {
            return nil
        }
        return UInt64(date.timeIntervalSince1970)
    }
    
    static func dayCodes(_ sharedSecret: SharedSecret, days: Int) -> [DayCode] {
        var hash = SHA.hash(data: sharedSecret)
        var values = [DayCode](repeating: 0, count: days)
        for i in (0 ... (days - 1)).reversed() {
            values[i] = JavaData.byteArrayToLong(digest: hash)
            let hashData = Data(hash)
            hash = SHA.hash(data: hashData)
        }
        return values
    }
    
    static func beaconCodeSeed(_ dayCode: DayCode) -> BeaconCodeSeed {
        let data = withUnsafeBytes(of: dayCode) { Data($0) }
        let reversed: [UInt8] = [data[0], data[1], data[2], data[3], data[4], data[5], data[6], data[7]]
        let hash = SHA.hash(data: Data(reversed))
        let seed = BeaconCodeSeed(JavaData.byteArrayToLong(digest: hash))
        return seed
    }
    
    private func day(_ timestamp: Timestamp) -> Day? {
        let time = UInt64(NSDate(timeIntervalSince1970: timestamp.timeIntervalSince1970).timeIntervalSince1970)
        let (epochDay,_) = (time - epoch).dividedReportingOverflow(by: UInt64(24 * 60 * 60))
        let day = Day(epochDay)
        guard day >= 0, day < values.count else {
            logger.fault("Day out of range")
            return nil
        }
        return day
    }
    
    private func get(_ timestamp: Timestamp) -> DayCode? {
        guard let day = day(timestamp) else {
            logger.fault("Day out of range")
            return nil
        }
        return values[Int(day)]
    }
    
    func seed(_ timestamp: Timestamp) -> (BeaconCodeSeed, Day)? {
        guard let day = day(timestamp), let dayCode = get(timestamp) else {
            logger.fault("Day out of range")
            return nil
        }
        let seed = ConcreteDayCodes.beaconCodeSeed(dayCode)
        return (seed, day)
    }
}

